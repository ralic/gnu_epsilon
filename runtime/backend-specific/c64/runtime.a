;;; epsilon runtime library for the Commodore 64 port, in ACME -*- asm -*-.
;;;
;;; Copyright (C) 2014 Luca Saiu
;;; Written by Luca Saiu

;;; This file is part of GNU epsilon.

;;; GNU epsilon is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.

;;; GNU epsilon is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.

;;; You should have received a copy of the GNU General Public License
;;; along with GNU epsilon.  If not, see <http://www.gnu.org/licenses/>.


;;;;; BASIC driver
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone BASIC_driver

;;; I don't even bother fixing the pointers delimiting BASIC RAM.
;;; The BASIC program here is never supposed to be changed, and is
;;; only for jumping to the machine-language code.  After the jump
;;; we could even overwrite it.

BASIC_START = $0801 ;; 2049
* = BASIC_START

BASIC_LINE_10:
;;; 10 SYSML_START
;;; FIXME: I've followed the documentation but there's something I don't
;;; understand here.  Small changes in this don't seem to affect anything,
;;; which is very strange.
!byte >BASIC_TERMINATOR, <BASIC_TERMINATOR

!word 10 ;; line number (low, high)
!byte $9e ;; SYS token
!byte character_0 + ((ML_START / 10000) % 10) ;; in practice this will be 0
!byte character_0 + ((ML_START / 1000) % 10)
!byte character_0 + ((ML_START / 100) % 10)
!byte character_0 + ((ML_START / 10) % 10)
!byte character_0 + (ML_START % 10)
!byte 0    ;; end-of-BASIC-line marker
BASIC_TERMINATOR:
!byte 0, 0 ;; end-of-BASIC-program marker
AFTER_BASIC_TERMINATOR:


;;;;; Machine-language end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone machine_language_end

;;; The last byte mapped to usable RAM.
ML_END = $cfff

;; Write a terminator byte at the end of usable memory.  This helps me
;; catch some mistakes: an attempt to write a different constant at
;; this address will fail at assembling time.
* = ML_END
ML_END:
!byte 0

;;; Don't write past ML_END, but start from the next useful address
;;; instead.
* = AFTER_BASIC_TERMINATOR


;;;;; Debugging support from BASIC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone debugging_support_from_BASIC

;; ;;; Experimental BASIC area: BEGIN
;; ;;; Reserve some space for BASIC program and variable.  This is only
;; ;;; useful for debugging, and should be commented-out in the end.
;; ML_START = BASIC_START + 2048
;; B1 = 3333 ;; a convenient addres to type from BASIC
;; * = B1
;; !byte 30
;; B2 = 3334 ;; another one
;; * = B2
;; !byte 31
;; * = ML_START ;; The machine-language driver has to start RIGHT HERE
;; ;; Experimental BASIC area: END


;;;;; Tentative: Reserve space for graphics (bank 0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone grapics

!fill 18000, 0 ;; obviously too much

;;;;; Special global definitions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Conventional values for constants not fitting in 16 bits.
;;; If we start really using them we're probably in trouble.
out_of_bounds_low = -32768
out_of_bounds_high = 32767

;;; A global datum which is not needed in compiled static code.
omitted = 0


;;;;; Machine-language driver
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone machine_language_driver

;;; FIXME: if this is inadequate find another good place in zeropage.
frame_pointer = $c1

;;; Zeropage two-byte areas, useful to pass values around, including pointers.
zeropage_arg1 = $02
zeropage_arg2 = $fb
zeropage_arg3 = $fd

ML_START:
        jsr disable_BASIC
        ;; jsr toggle_shifted_character_set
        jsr enable_shifted_character_set
        jsr initialize_runtime
        ;; jsr test_stack
        jsr epsilon_main_entry_point
        jsr reenable_BASIC
        rts


;;;;; Constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone constants

;;; real stuff
character_0 = 48
character_a = $41
character_z = (character_a + 25)

;;character_0 = $30
character_9 = (character_0 + 9)
character_plus = $2b
character_return = $0d
character_equals = $3d


;;;;; ROM routines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone ROM_routines

chrout = $ffd2
getin = $ffe4
stop = $ffe1


;;;;; Page mapping
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone page_mapping

disable_BASIC:
        lda #$36
        sta $01
        rts

reenable_BASIC:
        lda #$37
        sta $01
        rts


;;;;; Character-set, border and background color support
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone character_set_border_and_background_color_support

border = 53280
background = 53281

border_previous_color:
!byte 0

save_border:
        lda border
        sta border_previous_color
        rts
restore_border:
        lda border_previous_color
        sta border
        rts

;;; Parameter in A.
set_border:
        sta border
        rts

toggle_shifted_character_set:
        lda 53272
        eor #3
        sta 53272
        rts

enable_shifted_character_set:
        lda 53272
        ora #3
        sta 53272
        rts

disable_shifted_character_set:
        lda 53272
        and #!3
        sta 53272
        rts


;;;;; Runtime data structures
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone runtime_data_structures


;; ;;; Scratch area. [FIXME: remove]
;; scratch:
;; !fill 16, $ff ;; Reserve a little more space than we need.
;; scratch1 = scratch + 1
;; scratch2 = scratch + 2
;; scratch3 = scratch + 3
;; scratch4 = scratch + 4
;; scratch5 = scratch + 5
;; return1 = scratch + 6
;; return2 = scratch + 7

;;; User-defined stack.
;; Align to page [FIXME: why did I do that?  Is it important?], and
;; reserve one full page.
!align 255, 0
stack:
;; !fill 256, $ff
;; !byte 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 ;; FIXME: this is a temporary test!
!fill 256, $00

;;; Heap (no deallocation support yet)
heap_size = 2048
heap:
!fill heap_size, $00

;;; FIXME: is it worth to move this to pagezero?
heap_allocation_pointer:
  !16 heap

heap_limit = heap + heap_size

;;; Return-address passing area.  FIXME: is it worth to move this to pagezero?
return_address:
  !16 0


;;;;; Arithmetic routines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone arithmetic_routines

;;; Operand in A, quotient in X, remainder in A.
divide_by_10_8bit:
        ldx #0
divide_by_10_8bit_loop:
        cmp #10
        bcc divide_by_10_8bit_out:
        sec
        sbc #10
        inx
        jmp divide_by_10_8bit_loop
divide_by_10_8bit_out:
        rts


;;;;; I/O
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone IO

;;; Clobbers A, X, Y.
print_newline:
        lda #character_return
        jsr chrout
        rts

;;; Operand in [0, 10) in A.
;;; Clobbers X, Y.
print_decimal_digit:
        ora #$30 ;; Set high bits.
        jsr chrout
        rts

;;; Operand in A.  Clobbers X and Y.
print_decimal_8bit:
        ldy #0 ;; Hold the digit stack height in y.
        cmp #0
        bne print_decimal_8bit_fill_stack_loop
        ;; Special case: the number to print is zero.
        jmp print_decimal_digit ;; Tail call.
print_decimal_8bit_fill_stack_loop:
        cmp #1
        bcc print_decimal_8bit_print
        jsr divide_by_10_8bit
        pha ;; Push remainder digit.
        iny ;; Increment digit counter.
        txa ;; Continue to examine the quotient.
        jmp print_decimal_8bit_fill_stack_loop
print_decimal_8bit_print:
        sty print_decimal_8bit_digit_no
print_decimal_8bit_print_loop:
        lda print_decimal_8bit_digit_no
        cmp #0
        beq print_decimal_8bit_out
        dec print_decimal_8bit_digit_no
        pla
        jsr print_decimal_digit
        jmp print_decimal_8bit_print_loop
print_decimal_8bit_out:
        rts
print_decimal_8bit_digit_no:
        !byte 0

;;; Temporary version, printing MSB then LSB, both in decimal.
;;; Operand in A(LSB) and X(MSB).  Clobbers Y.
print_decimal_16bit:
        pha
        txa
        jsr print_decimal_8bit
        ;; jsr print_newline
        lda #character_plus
        jsr chrout
        ;; jsr print_newline
        pla
        jsr print_decimal_8bit
        jsr print_newline
        rts

;;; Parameter in A.  Clobbers X, Y.
io_write_character:
        jsr chrout
        rts

;;; FIXME: move.  However this is a good "visual" benchmark.
assembly_stripes:
        sec
outer:
        lda #15
inner:
        sta 53280
        sta 53281
        beq outer
        sbc #1
        jmp inner

;;; A manually unrolled version of assembly_stripes_.
assembly_stripes_unrolled:
        lda #15
        sta 53280
        sta 53281
        lda #14
        sta 53280
        sta 53281
        lda #13
        sta 53280
        sta 53281
        lda #12
        sta 53280
        sta 53281
        lda #11
        sta 53280
        sta 53281
        lda #10
        sta 53280
        sta 53281
        lda #9
        sta 53280
        sta 53281
        lda #8
        sta 53280
        sta 53281
        lda #7
        sta 53280
        sta 53281
        lda #6
        sta 53280
        sta 53281
        lda #5
        sta 53280
        sta 53281
        lda #4
        sta 53280
        sta 53281
        lda #3
        sta 53280
        sta 53281
        lda #2
        sta 53280
        sta 53281
        lda #1
        sta 53280
        sta 53281
        lda #0
        sta 53280
        sta 53281
        jmp assembly_stripes

;;;;; Convenience macros, possibly to be used even in the compiler output
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!zone convenience_macros

;;; from -> to

!macro literal_to_16bit .literal, .destination_address {
        lda #<.literal
        sta .destination_address
        lda #>.literal
        sta .destination_address + 1
}

!macro stack_to_absolute_16bit .slot, .destination_address {
        ldy #(.slot * 2)
        lda (frame_pointer), y
        sta .destination_address
        iny
        lda (frame_pointer), y
        sta .destination_address + 1
}

!macro absolute_to_stack_16bit .source_address, .slot {
        lda .source_address
        ldy #(.slot * 2)
        sta (frame_pointer), y
        lda .source_address + 1
        iny ;; ldy #(.slot * 2 + 1) would also work and would be just as fast, but iny is smaller
        sta (frame_pointer), y
}

;;; Leave the MSB alone, without overwriting it.  If only the LSB is
;;; read later, it's perfectly safe to ignore the second byte of the
;;; slot -- at least until I add tracing garbage collection.
!macro a_to_stack_8bit .slot {
        ldy #(.slot * 2)
        sta (frame_pointer), y
}

!macro a_to_stack_msb_8bit .slot {
        ldy #(.slot * 2 + 1)
        sta (frame_pointer), y
}

!macro literal_to_stack_8bit .literal, .slot {
        lda #.literal
        +a_to_stack_8bit .slot
}

!macro literal_to_stack_msb_8bit .literal, .slot {
        lda #.literal
        +a_to_stack_msb_8bit .slot
}

!macro literal_to_stack_16bit .literal, .slot {
        lda #<.literal
        ldy #(.slot * 2)
        sta (frame_pointer), y
        lda #>.literal
        iny
        sta (frame_pointer), y
}

!macro stack_to_a_8bit .slot {
        ldy #(.slot * 2)
        lda (frame_pointer), y
}

!macro stack_msb_to_a_8bit .slot {
        ldy #(.slot * 2 + 1)
        lda (frame_pointer), y
}

;;; Set the first byte of the slot (by convention low byte) to A and
;;; the second (by convention high byte) to X.
!macro stack_to_a_and_x_16bit .slot {
        ldy #(.slot * 2 + 1)
        lda (frame_pointer), y
        tax
        dey
        lda (frame_pointer), y
}

;;; Set the first byte of the slot (by convention low byte) to X and
;;; the second (by convention high byte) to A.
!macro stack_to_x_and_a_16bit .slot {
        ldy #(.slot * 2)
        lda (frame_pointer), y
        tax
        iny
        lda (frame_pointer), y
}

!macro stack_to_stack_8bit .fromslot, .toslot {
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        ldy #(.toslot * 2)
        sta (frame_pointer), y
}

!macro stack_to_stack_16bit .fromslot, .toslot {
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ldy #(.fromslot * 2 + 1)
        lda (frame_pointer), y
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
}



;;; This is needed to work around the famous 6502 bug about not
;;; fetching from the correct address if the indirect address is on a
;;; page boundary.  Having the first byte on an even address is enough.
;;; FIXME: is this worth to move to zeropage?
!align 2, 0
jump_to_stack_location:
!byte 0, 0

!macro jump_to_stack_16bit .slot {
        ldy #(.slot * 2)
        lda (frame_pointer), y
        sta jump_to_stack_location
        iny
        lda (frame_pointer), y
        sta jump_to_stack_location + 1
        jmp (jump_to_stack_location)
;;; This has the same cycle count as the previous implementation, but is
;;; slightly bigger because of the two sta's.
;; ;;; Non-reentrant (self-modifying code).
;;         ldy #(.slot * 2)
;;         lda (frame_pointer), y
;;         sta .instruction_to_modify + 1
;;         iny
;;         lda (frame_pointer), y
;;         sta .instruction_to_modify + 2
;; .instruction_to_modify:
;;         jmp $ffff
}

!macro adjust_frame_pointer_16bit .slot_delta {
        clc
        ;; Update the frame pointer LSB.
        lda frame_pointer
        adc #<(.slot_delta * 2)
        sta frame_pointer
        ;; Update the frame pointer MSB.
        lda frame_pointer + 1
        adc #>(.slot_delta * 2)
        sta frame_pointer + 1

!if (.slot_delta * 2 / 256) <> 0 {
        !error "Very large adjustment: this is suspect"
        }
}

;;; Non-reentrant (self-modifying code).
!macro io_load_byte_8bit .fromslot, .toslot {
        ;; Read the byte into A.
        +stack_to_absolute_16bit .fromslot, .instruction_to_modify + 1
.instruction_to_modify:
        lda $ffff
        ;; Store A into .toslot's LSB.
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; We don't care about the MSB: leave it as it is.
}

;;; Non-reentrant (self-modifying code).
!macro io_store_byte_8bit .fromslot1, .fromslot2 {
        ;; Modify the store instruction which will be executed in the end,
        ;; inserting the destination address.
        +stack_to_absolute_16bit .fromslot1, .instruction_to_modify + 1
        ;; Load A with the byte to store.  We couldn't do that before, since
        ;; stack_to_absolute_16bit clobbers A.
        +stack_to_a_8bit .fromslot2
.instruction_to_modify:
        sta $ffff
}

!macro bitwise_not_stack_16bit .fromslot, .toslot {
        ;; Xor the LSB with an all-1 bitmask:
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        eor #255
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; Xor the MSB with an all-1 bitmask:
        ldy #(.fromslot * 2 + 1)
        lda (frame_pointer), y
        eor #255
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
}

!macro bitwise_and_stack_16bit .fromslot1, .fromslot2, .toslot {
        ;; And LSB:
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2)
        and (frame_pointer), y
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; And MSB:
        ldy #(.fromslot1 * 2 + 1)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2 + 1)
        and (frame_pointer), y
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
}

!macro bitwise_or_stack_16bit .fromslot1, .fromslot2, .toslot {
        ;; And LSB:
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2)
        ora (frame_pointer), y
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; And MSB:
        ldy #(.fromslot1 * 2 + 1)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2 + 1)
        ora (frame_pointer), y
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
}

!macro bitwise_xor_stack_16bit .fromslot1, .fromslot2, .toslot {
        ;; And LSB:
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2)
        eor (frame_pointer), y
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; And MSB:
        ldy #(.fromslot1 * 2 + 1)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2 + 1)
        eor (frame_pointer), y
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
}


!macro sum_stack_8bit .fromslot1, .fromslot2, .toslot {
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        clc
        ldy #(.fromslot2 * 2)
        adc (frame_pointer), y
        ldy #(.toslot * 2)
        sta (frame_pointer), y
}

!macro sum_16bit .fromaddress1, .fromaddress2, .toaddress {
        ????
}

!macro sum_stack_16bit .fromslot1, .fromslot2, .toslot {
        ;; Load the first operand low byte.
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        ;; Sum it to the first byte of the second operand and store the result.
        clc
        ldy #(.fromslot2 * 2)
        adc (frame_pointer), y
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; Keep the carry bit and work with the high byte.
        ldy #(.fromslot1 * 2 + 1)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2 + 1)
        adc (frame_pointer), y
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
}

!macro subtract_stack_8bit .fromslot1, .fromslot2, .toslot {
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        sec
        ldy #(.fromslot2 * 2)
        sbc (frame_pointer), y
        ldy #(.toslot * 2)
        sta (frame_pointer), y
}

!macro subtract_stack_16bit .fromslot1, .fromslot2, .toslot {
        ;; Load the first operand low byte.
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        ;; Subtract the first byte of the second operand from it and store the result.
        sec
        ldy #(.fromslot2 * 2)
        sbc (frame_pointer), y
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; Keep the carry bit and work with the high byte.
        ldy #(.fromslot1 * 2 + 1)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2 + 1)
        sbc (frame_pointer), y
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
}

!macro multiply_stack_8bit .fromslot1, .fromslot2, .toslot {
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2)
        ldx (frame_pointer), y
        jsr multiply_8bit
        ldy #(.toslot * 2)
        sty (frame_pointer), y
}

!macro left_shift_1_stack_16bit .fromslot, .toslot {
        clc
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        rol
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ldy #(.fromslot * 2 + 1)
        lda (frame_pointer), y
        rol
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
}

!macro logic_right_shift_1_stack_16bit .fromslot, .toslot {
        ldy #(.fromslot * 2 + 1)
        lda (frame_pointer), y
        lsr
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        ror
        ldy #(.toslot * 2)
        sta (frame_pointer), y
}

!macro arithmetic_right_shift_1_stack_16bit .fromslot, .toslot {
        ldy #(.fromslot * 2 + 1)
        ;; Set the carry flag to 1 iff the high byte sign is negative
        lda (frame_pointer), y ;; set the negative flag
        clc
        bpl .dontset
        sec
.dontset:
        ror ;; propagate carry in the high byte as well
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        ror
        ldy #(.toslot * 2)
        sta (frame_pointer), y
}

sum_16_bit_a:
sum_16_bit_result:
!byte 0, 0
sum_16_bit_b:
!byte 0, 0
;;; Arguments in memory.  Overwrite the first.  Clobber A.
sum_16_bit:
        ;; Load the first operand low byte.
        lda sum_16_bit_a
        clc
        adc sum_16_bit_b
        sta sum_16_bit_result
        lda sum_16_bit_a + 1
        adc sum_16_bit_b + 1
        sta sum_16_bit_result + 1
        rts

left_shift_1_16bit_a:
left_shift_1_16bit_result:
!byte 0, 0
;;; Argument in memory.  Overwrite it.  Clobber A.
left_shift_1_16bit:
        ;; Load the first operand low byte.
        clc
        rol left_shift_1_16bit_a
        rol left_shift_1_16bit_a + 1
        rts

debug_fail_string:
  !pet "Failure", 0
!macro debug_fail {
        jsr print_newline
        +print_string debug_fail_string
.label:
        jmp .label
}

;;; Useful for debugging.  Unfortunately there's no way to pass strings
;;; as parameters in ACME.
;;; FIXME: make it into a procedure.
!macro print_string .string_label {
        ldy #0
.again:
        lda .string_label, y
        beq .out
        jsr chrout
        iny
        jmp .again
.out:
        jsr print_newline
}

!macro print_stack .slot {
        +stack_to_a_and_x_16bit .slot
        jsr print_decimal_16bit
}

!macro swap_memory_8bit .address1, .address2 {
        lda .address1
        ldx .address2
        sta .address2
        stx .address1
}

!macro swap_memory_16bit .address1, .address2 {
        +swap_memory_8bit .address1, .address2
        +swap_memory_8bit .address1 + 1, .address2 + 1
}

!macro equal_stack_16bit .fromslot1, .fromslot2, .toslot {
        ;; Compare LSBs.
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2)
        sec
        sbc (frame_pointer), y
        beq .lsbs_equal
.different:
        lda #0
        jmp .set_a_as_result
.lsbs_equal:
        ;; Compare MSBs.
        ldy #(.fromslot1 * 2 + 1)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2 + 1)
        sec
        sbc (frame_pointer), y
        bne .different
        lda #1
.set_a_as_result:
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; The result MSB is always 0.
        lda #0
        iny
        sta (frame_pointer), y
}

!macro not_equal_stack_16bit .fromslot1, .fromslot2, .toslot {
        ;; Compare LSBs.
        ldy #(.fromslot1 * 2)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2)
        sec
        sbc (frame_pointer), y
        beq .lsbs_equal
.different:
        lda #1
        jmp .set_a_as_result
.lsbs_equal:
        ;; Compare MSBs.
        ldy #(.fromslot1 * 2 + 1)
        lda (frame_pointer), y
        ldy #(.fromslot2 * 2 + 1)
        sec
        sbc (frame_pointer), y
        bne .different
        lda #0
.set_a_as_result:
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; The result MSB is always 0.
        lda #0
        iny
        sta (frame_pointer), y
}

!macro jump_when_zero_stack_16bit .fromslot, .destination {
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        bne .after
        iny
        lda (frame_pointer), y
        ;; beq could only jump a short range away, and I'm generating long basic blocks.
        bne .after
        jmp .destination
.after:
}

!macro jump_when_zero_stack_8bit .fromslot, .destination {
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        ;; beq could only jump a short range away, and I'm generating long basic blocks.
        bne .after
        jmp .destination
.after:
}

!macro jump_unless_zero_stack_8bit .fromslot, .destination {
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        ;; bne could only jump a short range away, and I'm generating long basic blocks.
        beq .after
        jmp .destination
.after:
}

!macro increment_stack_16bit .fromslot, .toslot {
        +sum_stack_immediate_16bit .fromslot, 1, .toslot
}

!macro decrement_stack_16bit .fromslot, .toslot {
        +sum_stack_immediate_16bit .fromslot, -1, .toslot
}

!macro sum_stack_immediate_16bit .fromslot, .immediate, .toslot {
        clc
        ;; Sum LSBs.
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        adc #<(.immediate)
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; Sum MSBs, with carry.
        ldy #(.fromslot * 2 + 1)
        lda (frame_pointer), y
        adc #>(.immediate)
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
}

!macro negate_stack_16bit .fromslot, .toslot {
        ;; Store 1's complement of (.fromslot) into .toslot:
        ldy #(.fromslot * 2)
        lda (frame_pointer), y
        eor #$ff
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ldy #(.fromslot * 2 + 1)
        lda (frame_pointer), y
        eor #$ff
        ldy #(.toslot * 2 + 1)
        sta (frame_pointer), y
        +increment_stack_16bit .toslot, .toslot
}

;;; The result MSB is always 0, and not represented.
!macro negative_stack_16bit .fromslot, .toslot {
        ;; Only look at the MSB sign
        ldx #0
        ldy #(.fromslot * 2 + 1)
        lda (frame_pointer), y
        bpl .store_result
        inx
.store_result:
        txa
        ldy #(.toslot * 2)
        sta (frame_pointer), y
        ;; ;; The result MSB is always 0.
        ;; lda #0
        ;; iny
        ;; sta (frame_pointer), y
}

;;; Parameters in zeropage_arg1 and zeropage_arg2.  Result LSB in A.
;;; Result MSB is always zero, and not represented.  Doesn't clobber
;;; anything.
less_than_or_equal_to_16bit:
        ;; Compare MSBs first, signs and all.
        lda zeropage_arg1 + 1
        cmp zeropage_arg2 + 1
        beq compare_lsbs
        jmp less_than_16bit ;; The two parameters are not equal.
compare_lsbs:
        ;; MSBs are equal: in this easier case we can avoid sign
	;; comparisons, and do away with less_than_16bit.
        lda zeropage_arg2
        cmp zeropage_arg1
        bcs less_than_or_equal_to_16bit_return_true
        lda #0
        rts
less_than_or_equal_to_16bit_return_true:
        lda #1
        rts

;;; Parameters in zeropage_arg1 and zeropage_arg2.  Result LSB in A.
;;; Result MSB is always zero, and not represented.  Doesn't clobber
;;; anything.
less_than_16bit:
        ;; Compare signs.
        lda zeropage_arg1 + 1
        bmi negative_unknown
        lda zeropage_arg2 + 1
        bmi nonnegative_negative
;; same sign: in two's complement I can just compare unsigned representations.
same_sign:
        ;; When I arrive here, from either path, I have the second MSB in A.
        cmp zeropage_arg1 + 1 ; set C if second MSB >= first MSB, Z if equal
        beq first_bytes_equal
        bcc nonnegative_negative ; second MSB < first MSB: return #0
        ;; If we arrived here then second MSB > first MSB: return #1
        jmp negative_nonnegative
first_bytes_equal:
        lda zeropage_arg1
        cmp zeropage_arg2 ; set C if first LSB >= second LSB
        bcc negative_nonnegative ; first LSB < second LSB: return #1
        lda #0 ; trade space for speed: don't jump to nonnegative_negative
        rts
negative_unknown:
        lda zeropage_arg2 + 1
        bmi same_sign ; negative_negative
negative_nonnegative:
        lda #1
        rts
nonnegative_negative:
        lda #0
        rts

;;; The MSB is always zero and not represented.
!macro less_than_stack_16bit .fromslot1, .fromslot2, .toslot {
        ;; Call the procedure doing the actual work.
        +stack_to_absolute_16bit .fromslot1, zeropage_arg1
        +stack_to_absolute_16bit .fromslot2, zeropage_arg2
        jsr less_than_16bit
        ;; Store the LSB.
        +a_to_stack_8bit .toslot
        ;; ;; Store the MSB.  I rely on a_to_stack_8bit leaving Y to
        ;; ;; #(.toslot * 2).
        ;; iny
        ;; lda #0
        ;; sta (frame_pointer), y
}

!macro greater_than_stack_16bit .fromslot1, .fromslot2, .toslot {
        +less_than_stack_16bit .fromslot2, .fromslot1, .toslot
}

!macro less_than_or_equal_to_stack_16bit .fromslot1, .fromslot2, .toslot {
        ;; Call the procedure doing the actual work.
        +stack_to_absolute_16bit .fromslot1, zeropage_arg1
        +stack_to_absolute_16bit .fromslot2, zeropage_arg2
        jsr less_than_or_equal_to_16bit
        ;; Store the LSB.
        +a_to_stack_8bit .toslot
        ;; Store the MSB.  I rely on a_to_stack_8bit leaving Y to
	;; #(.toslot * 2).
        iny
        lda #0
        sta (frame_pointer), y
}

!macro greater_than_or_equal_to_stack_16bit .fromslot1, .fromslot2, .toslot {
        +less_than_or_equal_to_stack_16bit .fromslot2, .fromslot1, .toslot
}

;;; Parameter in zeropage_arg1.  Clobber A and zeropage_arg1.  No result.
add_words_to_heap_allocation_pointer_16bit:
        ;; Double zeropage_arg1, to have it in bytes rather than in words.
        clc
        rol zeropage_arg1
        rol zeropage_arg1 + 1
        ;; Add <zeropage_arg1 to <heap_allocation_pointer.
        clc ; FIXME: unless the increment is ridiculously high, this won't be needed.
        lda heap_allocation_pointer
        adc zeropage_arg1
        sta heap_allocation_pointer
        ;; Add >zeropage_arg1 to >heap_allocation_pointer, with carry.
        lda heap_allocation_pointer + 1
        adc zeropage_arg1 + 1
        sta heap_allocation_pointer + 1
        rts

!macro buffer_make_stack_16bit .fromslot, .toslot {
        ;; Pass the increment to the routine, without calling it yet.
        ;; We need to do this before setting the result, as .fromslot and
        ;; .toslot might be equal.
        +stack_to_absolute_16bit .fromslot, zeropage_arg1
        ;; The result is always equal to the current allocation
        ;; pointer.  Set it now, because the routine will change it.
        +absolute_to_stack_16bit heap_allocation_pointer, .toslot
        ;; Now we can finally call the routine, which returns nothing.
        ;; We have already set the result.
        jsr add_words_to_heap_allocation_pointer_16bit
}

!macro buffer_get_stack_16bit .fromslot1, .fromslot2, .toslot {
        +stack_to_absolute_16bit .fromslot1, zeropage_arg1
        +stack_to_absolute_16bit .fromslot2, zeropage_arg2
        jsr buffer_get_16bit
        +absolute_to_stack_16bit zeropage_arg1, .toslot
}

!macro buffer_set_stack_16bit .fromslot1, .fromslot2, .fromslot3 {
        +stack_to_absolute_16bit .fromslot1, zeropage_arg1
        +stack_to_absolute_16bit .fromslot2, zeropage_arg2
        +stack_to_absolute_16bit .fromslot3, zeropage_arg3
        jsr buffer_set_16bit
}

;;; Single parameter and result in zeropage_arg1.
;;; Clobbers A, Y.
load_16bit:
        ldy #0
        lda (zeropage_arg1), y
        sta zeropage_arg1
        iny
        lda (zeropage_arg1), y
        sta zeropage_arg1 + 1
        rts

;;; Address parameter in zeropage_arg1, offset parameter (in 16-bit words)
;;; in zeropage_arg2, result in zeropage_arg1.
;;; Clobbers A, Y, zeropage_arg2.
buffer_get_16bit:
        ;; Left-shift zeropage_arg2.
        lda zeropage_arg2
        asl
        sta zeropage_arg2
        lda zeropage_arg2 + 1
        rol
        sta zeropage_arg2 + 1
        ;; Sum zeropage_arg1 and zeropage_arg2 into zeropage_arg2.
        clc
        lda zeropage_arg1
        adc zeropage_arg2
        sta zeropage_arg2
        lda zeropage_arg1 + 1
        adc zeropage_arg2 + 1
        sta zeropage_arg2 + 1
        ;; Load from the pointer at zeropage_arg2 into zeropage_arg1.
        ldy #0
        lda (zeropage_arg2), y
        sta zeropage_arg1
        iny
        lda (zeropage_arg2), y
        sta zeropage_arg1 + 1
        rts

;;; Address parameter in zeropage_arg1, offset parameter (in 16-bit words)
;;; in zeropage_arg2, new-content parameter in zeropage_arg3.
;;; Clobbers A, Y, zeropage_arg2.
buffer_set_16bit:
        ;; Left-shift zeropage_arg2.
        lda zeropage_arg2
        asl
        sta zeropage_arg2
        lda zeropage_arg2 + 1
        rol
        sta zeropage_arg2 + 1
        ;; Sum zeropage_arg1 and zeropage_arg2 into zeropage_arg2.
        clc
        lda zeropage_arg1
        adc zeropage_arg2
        sta zeropage_arg2
        lda zeropage_arg1 + 1
        adc zeropage_arg2 + 1
        sta zeropage_arg2 + 1
        ;; Store data at zeropage_arg3 into the pointer at zeropage_arg2.
        lda zeropage_arg3
        ldy #0
        sta (zeropage_arg2), y
        lda zeropage_arg3 + 1
        iny
        sta (zeropage_arg2), y
        rts

;; FIXME: 16-bit copies should probably be done like this:
;; 	lda .source
;;      ldx .source + 1
;; 	sta .target
;; 	stx .target + 1


;;; FIXME: move to the runtime block
initialize_runtime:
        ;; Store the initial frame pointer in our zeropage pointer.
        lda #<stack
        sta frame_pointer
        lda #>stack
        sta frame_pointer + 1
        rts


test_stack:
        ;; BEGIN ------------------------------
        ;; +literal_to_stack_16bit 32 + 256 * 3, 2
        ;; +literal_to_stack_16bit 10 + 256 * 2, 3
        ;; +literal_to_stack_16bit 12345, 2;; 13 * 256 + 37, 2
        ;; +literal_to_stack_16bit 1000, 3;; 13 * 256 + 37, 3
        +literal_to_stack_16bit -2, 2;; 13 * 256 + 37, 2
        +literal_to_stack_16bit -2, 3;; 13 * 256 + 37, 3
        +print_stack 2
        +print_stack 3
        jsr print_newline
        ;; +sum_stack_16bit 2, 3, 4
        ;; +subtract_stack_16bit 2, 3, 4
        ;; ;; +multiply_stack_8_bit 2, 3, 4
        ;; +left_shift_1_stack_16bit 2, 4
        ;; +not_equal_stack_16bit 2, 3, 4
        +less_than_or_equal_to_stack_16bit 2, 3, 4
        ;; +negate_stack_16bit 2, 4
        ;; ;; +divide_stack_16bit 2, 3, 4
        ;; +logic_right_shift_1_stack_16bit 2, 4
        ;; +sum_stack_16bit 2, 3, 4
        +print_stack 2
        +print_stack 3
        +print_stack 4

        rts
after:
        lda #11
        jsr set_border
        rts


;;;;; Scratch
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

